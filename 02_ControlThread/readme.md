### 1. 어떻게 OS는 CPU에서 여러 프로그램을 실행할수 있을까?

CPU는 한 순간에 하나의 명령어 흐름만 실행하지만, 운영체제가 아주 빠르게 실행 대상을 바꿔가며
여러 프로그램(쓰레드가)이 동시에 실행되는 것처럼 보이게 만든다. 이 역할을 하는것이 OS의 스케줄러(scheduler)이다.
CPU 혼자서는 절대 “바꿔 실행” 못하므로  OS가 개입할 수 있는 타이밍이 필요함.

퀀텀(Time Quantum)은 운영체제가 하나의 스레드에게 “연속적으로 CPU를 점유하여 사용할 수 있도록 허용하는 최대 시간”이다.
운영체제는 하드웨어 타이머 인터럽트를 이용해 스레드의 실행 시간을 측정하고, 퀀텀이 소진되면 
스케줄러가 개입해 필요하면 선점(preemption: 실행 중인 스레드의 CPU를 운영체제가 강제로 회수하는 것)하고 다른 쓰레드에 CPU를 담당한다.
이때의 CPU의 레지스터 상태를 저장/복원하는 작업을 문맥 교환(context switch)이라고 한다. 

퀀텀을 확인하는 타이머 인터럽트 뿐만아니라 운영체제는 다양한 이벤트(예: I/O 사용, 동기화 오브젝트 신호 등)를 감지하여 
스레드의 상태를 변경하고 스케줄링 결정을 내린다.

OS가 개입하는 순간: 인터럽트

대표적인 인터럽트 : 
⏱ 타이머 인터럽트 : “너 지금 너무 오래 썼어”
⌨️ I/O 인터럽트: 키보드, 마우스, 디스크, 네트워크
🚨 시스템 콜 : 스레드가 OS 기능을 요청할 때

이 인터럽트가 발생하면:

CPU는 현재 실행 중인 스레드를 멈춤
OS 커널 코드로 점프
스케줄러 실행


### 2. OS에서 스레드 상태(Thread State)의 정의

```
[Ready] , [Running], [Blocked(Waiting)], [Terminated]


+----------+      dispatch      +----------+
|  READY   |------------------->| RUNNING  |
+----------+                    +----------+
     ^                               |
     |                               |
     |      preempt (quantum/pri)    |  wait/sleep/io
     +-------------------------------+----------------+
                                     |                |
                                     v                |
                                +----------+          |
                                | BLOCKED  |          |
                                | WAITING  |          |
                                +----------+          |
                                     |                |
                                     | unblock        |
                                     +----------------+
                                     |
                                     | return/exit
                                     v
                                +----------+
                                |TERMINATED|
                                +----------+                   
                                
READY -> RUNNING: 디스패치(코어 할당)
RUNNING -> READY: 선점(퀀텀 소진/우선순위)
RUNNING -> BLOCKED: Wait/Sleep/I-O로 대기 진입
BLOCKED -> READY: 이벤트/I-O 완료로 깨어남(unblock)
RUNNING -> TERMINATED: 스레드 함수 종료(return/exit)
```

## Running (실행 중)

스레드가 지금 이 순간 실제 CPU 코어 위에서 명령어를 실행 중인 상태.
코어가 N개면, 동시에 Running인 스레드는 최대 N개.
커널 관점에서 실제로 일어나는 일 
스레드는 **현재 CPU의 “현재 실행 스레드(current thread)”**로 선택됨.
스레드의 레지스터 컨텍스트가 CPU에 로드되어 있음
RIP/EIP(다음 명령어), RSP/ESP(스택 포인터), 일반 레지스터, SIMD 상태 일부 등
타이머 인터럽트(틱)나 더 높은 우선순위 스레드 등장 등으로 언제든 Running에서 내려올 수 있음
Running에서 빠져나오는 대표 케이스

타임 슬라이스(퀀텀) 소진 → Ready로 (선점 스케줄링)
더 높은 우선순위 스레드가 Ready가 됨 → Ready로 (선점)
락/이벤트/I/O를 기다리는 API 호출 → Blocked로
스레드 종료 → Terminated로


## Ready (실행 가능, 하지만 CPU를 못 받은 상태)

스레드가 실행에 필요한 조건을 모두 만족했는데,
아직 CPU 코어에 배정되지 않은 상태.
커널 관점에서 실제로 일어나는 일
스레드는 Ready Queue(실행 대기열) 같은 스케줄링 자료구조에 들어감.
스케줄러는 우선순위/CPU 부하/어피니티 등을 고려해서
Ready 상태 스레드 중 하나를 뽑아 Running으로 보냄(디스패치)
Ready가 되는 대표 케이스
새로 생성된 스레드가 시작 가능해짐
Blocked 상태에서 기다리던 이벤트가 발생함(Wait 해제)
Running 중 선점(preempt) 당함(퀀텀 소진 or 우선순위 밀림)
Ready 상태에서 “못 도는” 이유 예시
CPU가 이미 다른 스레드로 꽉 차 있음
우선순위가 낮아서 계속 밀림(Starvation 가능)
어피니티 때문에 특정 코어만 기다리느라 지연


## Blocked / Waiting (대기 중)

 의미
 * 스레드가 스스로 실행을 못 하는 상태 
   어떤 조건이 충족될 때까지 기다려야 함
 * 그래서 스케줄러 관점에서 실행 후보(Ready Queue)에서 제외됨.

한 문장으로: “조건이 충족되기 전까지는 CPU 줘도 할 일이 없어서, 잠들어 있는 상태.”

커널 관점에서 실제로 일어나는 일
 * 스레드는 Ready Queue에서 빠지고,
 * 대기 대상 오브젝트의 Wait List(대기자 명단)에 등록됨.
   예: Event/Mutex/Semaphore/Timer/I/O completion 등
 * 기다리는 조건이 만족되면 커널이 그 스레드를 Ready로 깨움(unblock)

Blocked로 들어가는 대표 원인(= 기다리는 대상)
 * 시간 대기: Sleep, 타이머
 * 동기화 오브젝트 대기: WaitForSingleObject, 조건변수 wait
 * I/O 대기: 파일/네트워크/디바이스 I/O 완료
 * 락 경합: mutex를 얻을 때까지 대기(커널 mutex일 경우)
 * (고급) APC/Alertable wait 같은 특수 대기

Blocked에서 깨는 대표 케이스
 * 이벤트 Set / 세마포어 Release
 * 타이머 만료
I/O 완료
조건변수 notify
타임아웃 발생(그냥 Ready로 돌아오되 “실패/timeout” 결과)